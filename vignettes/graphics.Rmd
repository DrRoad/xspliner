---
title: "xspliner package - graphics"
author: "Krystian Igras"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This documents presents possible options how the final model can be described through plots and graphics

# Single variable results

As you we actually saw in previous sections, the model tranformation can be presented on simple graphics.
In continuous predictor case, the transformation is plotted as estimated spline - in case of discrete predictor, factorMerget plot is used.

For quantitative predictors some additional options are offered. Let'd check them in below examples.

Let's use already known Boston Housing Data, and random forest model.
```{r}
library(pdp)
data(boston)
str(boston)
data(boston)
set.seed(123)

library(randomForest)
boston.rf <- randomForest(cmedv ~ lstat + ptratio + age, data = boston)
```

Also let's build xspliner model with lstat and ptratio transformation.
```{r}
library(xspliner)
model_xs <- xspline(cmedv ~ xs(lstat) + xs(ptratio) + age, model = boston.rf)
```

In order to plot specified predictor transformation just use:
```{r}
plot(model_xs, "lstat")
```

You can also add some additional information for the plot.

**Plotting training data**

Just add two parameters: `data = <training data>` and flag `plot_data = TRUE`.
```{r}
plot(model_xs, "lstat", data = boston, plot_data = TRUE)
```

***Plotting approximation derivative**

The derivative is plotted on scale of the second axis. To display it just add: `plot_deriv = TRUE`.
```{r}
plot(model_xs, "lstat", plot_deriv = TRUE)
```

You can also specify if model effect or transition should be displayed. Parameters responsible for that are `plot_response` and `plot_approx` respectively.

For example below we display just the approximation and derivative for ptratio variable:
```{r}
plot(model_xs, "ptratio", plot_response = FALSE, plot_deriv = TRUE)
```

# Models comparison

As we may want to compare final GLM model with its parent black box, xspliner provides one simple tool.

For comparison just add model parameter for plot method, and provide data:
```{r}
plot(model_xs, model = boston.rf, data = boston)
```

The resulting graphics compares predicted values for both GLM and black box model.

To predict the values the standard method is used: `function(object, newdata) predict(object, newdata)`.
So for regression models the results are on the same scale.

The notable difference occurs in classification models. GLM models by default return "link" function values, so for classification it can be any real number. Contrary to that, randomForest function returns predicted levels.

To avoid the problem, `predictor_funs` parameter was introduced. This is the list of prediction functions for each model (in order: black box, xspliner). Let's see it on SVM example:

```{r}
iris_data <- droplevels(iris[iris$Species != "setosa", ])

library(e1071) 
library(xspliner)
model_svm <- svm(Species ~  Sepal.Length + Sepal.Width + Petal.Length + Petal.Width, 
                 data = iris_data, probability = TRUE)

model_xs <- xspline(Species ~  xs(Sepal.Length) + xs(Sepal.Width) + xs(Petal.Length) + xs(Petal.Width),
                    model = model_svm)
```

Now we specify predict functions to return probability of virginica response.
```{r}
prob_svm <- function(object, newdata) attr(predict(object, newdata = newdata, probability = TRUE), "probabilities")[, 2]
prob_xs <- function(object, newdata) predict(object, newdata = newdata, type = "response")
```

And plot the result
```{r}
plot(model_xs, model = model_svm, data = iris_data,
     prediction_funs = list(prob_svm, prob_xs)
)  
```

## Comparing with another models

Following above approach it's easy to generate similiar graphics for higher amount of models.

Just include additional models inside `compare_with` parameter (named list), and add corresponsing predict functions to them to `predictor_funs` parameter (if ommitted, the default one is used).

See below example on airquality data
```{r}
library(mgcv)

data(airquality)
ozone <- subset(na.omit(airquality),
                select = c("Ozone", "Solar.R", "Wind", "Temp"))
set.seed(123)

model_rf <- randomForest(Ozone ~ ., data = ozone)
model_xs <- xspline(Ozone ~ xs(Solar.R) + xs(Wind) * xs(Temp), model_rf, data = ozone)
model_glm <- glm(Ozone ~ ., data = ozone)
model_gam <- mgcv::gam(Ozone ~ s(Solar.R) + s(Wind) + s(Temp), data = ozone)

plot(model_xs, model = model_rf, data = ozone, compare_with = list(glm = model_glm, gam = model_gam))
```

# Class based plot

The resulting xspliner model is GLM. So you may use graphical analytics for xspliner just typing:
```{r}
plot(model_xs)
```
